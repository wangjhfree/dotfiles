**Git**


- [参考](#)
	- [Git官网](https://git-scm.com/)
	- [Gogs - Go Git Service](https://gogs.io/)
	- [猴子都能懂的Git入门](http://backlogtool.com/git-guide/cn/contents/)
	- [Git Community Book 中文版](http://gitbook.liuhui998.com/book.pdf)
	- [压缩Git仓库](http://stevelorek.com/how-to-shrink-a-git-repository.html)
- [Git安装](#Git安装)
- [GitConfig](#GitConfig)
- [搭建Git远程服务器](#搭建Git远程服务器)
- [操作远程仓库](#操作远程仓库)
- [操作分支](#操作分支)
- [操作版本](#操作版本)
- [忽略某些文件、文件夹不提交](#忽略某些文件、文件夹不提交)
- [后悔药](#后悔药)
- [Git一键推送多个远程仓库](#Git一键推送多个远程仓库)
- [查看提交日志](#查看提交日志)
- [有选择的合并](#有选择的合并)
- [stash未提交的更改](#stash未提交的更改)
- [多次修改后拆分提交-暂存文件的部分改动](#多次修改后拆分提交-暂存文件的部分改动)
- [压缩多个Commit](#压缩多个Commit)
- [差异查看](#差异查看)
- [子模块submodule相关操作命令](#子模块submodule相关操作命令)


### Git安装


### GitConfig

```
// 配置文件位置
1. /etc/gitconfig文件：包含系统上每一个用户及他们仓库的通用配置。如果使用带有 --system 选项的 git config 时，它会从此文件读写配置变量。
2. ~/.gitconfig 或 ~/.config/git/config文件：只针对当前用户。可以传递 --global 选项让 Git 读写此文件。
3. 当前使用仓库的Git目录中的config文件(就是.git/config)：针对该仓库。

// 检查配置信息
$ git config --list --system

// 设置
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com

// 免 账号密码输入,缓存认证信息
$ git config --global credential.helper store

```


###搭建Git远程服务器

```
// 1. 验证能连接远程服务器
$ ssh admin@server_ip

// 2. 服务器端
$ mkdir project.git
$ cd project.git
$ git --bare init

// 3. 客户端
$ cd project
$ git init
$ git add .
$ git commit -m 'initial commit'
$ git remote add origin git@gitserver:../project.git
$ git push origin master

```


###操作远程仓库

```
// 检出仓库
$ git clone git://github.com/jquery/jquery.git

// 添加远程仓库
$ git remote add origin git@gitserver:../project.git
                 [name]
// 查看远程仓库
$ git remote -v

// 删除远程仓库
$ git remote rm origin

// 拉取远程仓库
$ git pull origin master
           [name] [localbranchName]

// 推送远程仓库
$ git push origin master

// 强制推送更改
$ git push origin master --force

// 将本地分支test提交远程仓库作为master分支,或作为另一个test的分支
$ git push origin test:master
$ git push origin test:test

```


###操作分支

```
// 查看本地分支
$ git branch

// 查看远程分支
$ git branch -r
（如果还是看不到就先 git fetch origin 先）

// 创建本地新分支
$ git branch [name] --注新分支创建后不会自动切换当前分支

// 切换分支
$ git checkout [name]

// 创建新分支并切换到新分支
$ git checkout -b [name]

//直接检出远程分支
$ git checkout -b [name][remoteName]
  例:git checkout -b mynewbranch origin/dragon

// 删除分支
$ git branch -d [name]
  --[-d]选项只能删除已参与合并的分支，对于未合并分支无法删除，若强制删除一分支，可以使用-D选项

// 合并分支
$ git merge [name] --将名称为[name]的分支与当前分支合并

// 合并最后的2个提交
$ git rebase -i HEAD~2 ---- 数字2按需修改即可

// 创建远程分支（本地分支push到远程）
$ git push origin [name]

// 删除远程分支
$ git push origin:head/[name]或$ git push origin:[name]

// 修改分支名称
$ git branch -m <old_branch><new_branch>

// 创建空分支
$ git symbolic-ref HEAD refs/heads/[name]
$ rm .git/index
$ git clean -fdx

```


###操作版本

```
// 查看版本
$ git tag

// 创建版本
$ git tag [name]

// 删除版本
$ git tag -d [name]

// 查看远程版本
$ git tag -r

// 创建远程版本（本地版本push到远程）
$ git push origin [name]

// 删除远程版本
$ git push origin :refs/tags/[name]

// 合并远程仓库的tag到本地
$ git pull origin --tags

// 上传本地tag到远程仓库
$ git push origin --tags

// 创建带注释的tag
$ git tag -a [name] -m 'yourMessage'

```


###忽略某些文件、文件夹不提交

```
// 在仓库根目录下创建".gitignore"的文件，写入不需要文件夹名或文件，每个元素占一行，
例:
target
bin
*.db

```


###后悔药

```
// 删除当前仓库内未受版本管理的文件
$ git clean -f

// 恢复仓库到上一次的提交状态
$ git reset --hard

// 回退所有内容到上一个版本
$ git reset HEAD^

// 回退a.py这文件的版本到上一版本
$ git reset HEAD^ a.py

// 回退到某个版本
$ git reset 057d

// 将本地的状态回退到远程一样
$ git reset -hard origin/master

// 向前回退到第3个版本
$ git reset -soft HEAD~3

// 修改最后的提交日志
$ git commit --amend

```


###Git一键推送多个远程仓库

```
编辑本地仓库的.git/config文件：
[remote "all"]
    url = git@gitserver:home/test.git
    url = git@gitserver11:home/test.git
使用git push all 一键Push到多个远程仓库

```


###查看提交日志

```
// 查看文件中每行的作者、最新的变更提交和提交时间
$ git blame [filename]

// 查看仓库历史记录
--oneline -压缩模式，在每个提交的旁边显示经过精简的提交哈希码和提交信息，以一行显示。
--graph -图形模式，使用该选项辉在输出的左边回执一张基于文本格式的历史信息表示图，如果你查看的时单个分支的历史记录的话，该选项无效
--all -显示所有分支的历史记录
$ git log --oneline --graph --name-status

```


###有选择的合并

```
cherry-pick可以从不同的分支中检出一个单独的commit，并把它和你当前的分支合并。
	如果你已并行方式在处理两个或以上的分支，可能会发现一个在全部分支中都有的bug。若你在一个分支中解决了它。你可以使用cherry-pick命令把它commit到其它分支上去，而不会弄乱其它的文件或commit。
$ git cherry-pick [commitHash]

```


###stash未提交的更改

```
// 正在修改某个bug或者某个特性，又突然被要求展示工作。而现在所做的工作还不足以提交，这个阶段还无法进行展示（不能回到更改之前）。在这种情况下， git stash可以帮到忙了。stash在本质上会取走所有的变更并存储它们以备将来使用。
$ git stash

// 检查stash列表：
$ git stash list

// 想解除stash并且恢复未提交的变更，就进行apply stash：
$ git stash apply

// 如果只想留有余地进行apply stash，给apply添加特定的标识符：
$ git stash apply stash@{0}

```


###多次修改后拆分提交-暂存文件的部分改动

```
// 一般情况下，创建一个基于特性的提交是比较好的做法，意思是每次提交都必须代表一个新特性的产生或者是一个bug的修复。如果你修复了两个bug，或是添加了多个新特性但是却没有提交这些变化会怎样呢？在这种情况下，你可以把这些变化放在一次提交中。但更好的方法是把文件暂存(Stage)然后分别提交。
例:如你对一个文件进行了多次修改并且想把他们分别提交。这种情况下，可以在 add 命令中加上 -p 参数
$ git add -p [fileName]

```


###压缩多个Commit

```
// 用rebase命令把多个commit压缩成一个
$ git rebase -i HEAD~[number_of_commits]

// 如果你想要压缩最后两个commit，你需要运行下列命令：
$ git rebase -i HEAD~2
Docs:

```


###差异查看

```
// 获得两个版本间所有变更的文件列表
$ git diff --name-status HEAD~2 HEAD~3

// 查看最近两个提交之间的差异
$ git diff HEAD HEAD~1

// 查看第1个与第3个提交之间的差异
$ git diff HEAD HEAD~2

^ - 代表父提交，^n 表示第n个父提交，^相当于^1
git寻根：^和~的区别 - 分析得很到位
~ - 代表连续的提交，~n相当于连续的第n个提交

// 比较两个分支之间的差异
$ git diff master..test

// 比较master、test的共有父分支和 test 分支之间的差异
$ git diff master...test

// 比较当前工作目录与 test 分支的差异
$ git diff test

// 比较当前工作目录与上次提交的差异
$ git diff HEAD

// 比较当前工作目录下的lib目录与上次提交的差异
$ git diff HEAD -- ./lib

// 统计一下有哪些文件被改动，有多少行被改动
$ git diff --stat

// 查看下次提交时要提交的内容(staged,添加到索引中)
$ git diff --cached

```


###子模块submodule相关操作命令

```
// 添加子模块
$ git submodule add [url] [path]
    如：$ git submodule add git://github.com/soberh/ui-libs.git
    src/main/webapp/ui-libs

// 初始化子模块
$ git submodule init  ----只在首次检出仓库时运行一次就行

// 更新子模块
$ git submodule update ----每次更新或切换分支后都需要运行一下

// 删除子模块（分4步走哦）
1) $ git rm --cached [path]
2) 编辑“.gitmodules”文件，将子模块的相关配置节点删除掉
3) 编辑“ .git/config”文件，将子模块的相关配置节点删除掉
4) 手动删除子模块残留的目录

```
